---
title: 10844. 쉬운 계단 수
date: 2020-03-22
summary: N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)
tags:
    - Dynamic Programming
    - algorithm
---
## 문제

45656이란 수를 보자.

이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.

세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)

### 입력

첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

### 출력

첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

## Overview

일단 규칙성을 찾아 점화식을 세우기 위해 공책에 무작정 써봤다.

- **한 자리**
    1. 1 2 3 4 5 6 7 8 9
- **두 자리**
    1. 10 12
    2. 21 23
    3. 32 34
    4. 43 45
    5. 54 56
    6. 65 67
    7. 76 78
    8. 87 89
    9. 98
- **세 자리**
    1. 101 121 123
    2. 210 212 232 234
    3. 321 323 343 345
    4. 432 434 454 456
    5. 543 545 565 567
    6. 654 ...

여기정도까지만 해봐도 규칙성을 찾을 수 있었다. 우리가 신경쓸 건 **한 자리가 추가될 때 맨 뒤에 어떤 놈을 붙일 수 있는가**이므로 **맨 뒷 자릿수만 알고 있으면 된다**. 마지막 자릿수는 0~9까지 모두 가능하므로 크기가 10인 배열로 유지를 해준 뒤, 다음과 같은 점화식으로 표현할 수 있겠다.
:::tip
a[n][i] = a[n-1][i-1]+a[n-1][i+1]
:::
그런데 예외가 있다. 마지막 자릿수가 0 또는 9인 경우이다. 마지막 자리에 0을 추가할 때에는 직전 자릿수가 1인 경우밖에 없고, 9인 경우는 8밖에 없다. 따라서 이 경우는 따로 떼준다.
```
if i==0:
        a[n][i] = a[n-1][i+1]
if i==9:
        a[n][i] = a[n-1][i-1]
```

이 부분과 자료형, 나머지만 유념해서 구현하면 되겠다.

## first solution
```cpp
#include <stdio.h>

long long dp[101][10];

int main() {
    int n;
    scanf("%d", &n);
    dp[1][0]=0; dp[1][1]=1; dp[1][2]=1; dp[1][3]=1; dp[1][4]=1;
    dp[1][5]=1; dp[1][6]=1; dp[1][7]=1; dp[1][8]=1; dp[1][9]=1;
    for(int i=2; i<=n; i++) {
        for(int j=0; j<10; j++) {
            if(j == 0)
                dp[i][j] = dp[i-1][j+1];
            else if(1<=j && j<9)
                dp[i][j] = (dp[i-1][j-1] + dp[i-1][j+1]) % 1000000000;
            else if(j == 9)
                dp[i][j] = dp[i-1][j-1];
        }
    }
    printf("%lld\n", (dp[n][0]+dp[n][1]+dp[n][2]+dp[n][3]+dp[n][4]+dp[n][5]+dp[n][6]+dp[n][7]+dp[n][8]+dp[n][9])%1000000000);
    return 0;
}
```
최초 케이스만 하드코딩해 집어넣어준 뒤, 점화식을 돌린다. 자료형은 `long long`으로 해주고, 더할 때마다 나머지연산을 해 `overflow`를 방지했다.

### 결과

`맞았습니다!!`

## Conclusion

스스로 규칙을 찾아 해결해내서 기쁘다. `dp`에 감이 조금씩 잡히고 있다는 생각이 든다. 비슷한 유형의 문제만 풀고 있어서 그럴지도 모르지만..

## 최종코드

[github](https://github.com/shinjawkwang/bojPractice/blob/master/dynamic_programming/10844.cpp)