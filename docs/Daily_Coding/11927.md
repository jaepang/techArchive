# 11927. 최대힙
*2020. 01. 23*
## 문제
널리 잘 알려진 자료구조 중 최대 힙이라는 것이 있다. 최대 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.
 1. 배열에 자연수 `x`를 넣는다.
 2. 배열에서 가장 큰 값을 출력하고, 그 값을 배열에서 제거한다.
프로그램은 처음에 비어있는 배열에서 시작하게 된다.
### 입력
첫째 줄에 연산의 개수 `N(1≤N≤100,000)`이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 `x`가 주어진다. 
만약 `x`가 자연수라면 배열에 `x`라는 값을 넣는(추가하는) 연산이고, `x`가 `0`이라면 배열에서 가장 큰 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 
입력되는 자연수는 `2^31`보다 작다.
### 출력
입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.
## Overview
[최소힙 문제](/Daily_Coding/1927.html) 에서 이름, 부등호 방향만 바꾸면 해결되는 문제라, 가볍게 맞추고 넘어가려 했다. 그러나..
## 엥?
부등호만 바꿔서 낸 코드가 `틀렸습니다`를 받았다. 안바꾼 부분이 있나 다시 들여다봤지만 문제는 없었다. 테스트 삼아 이리저리 해보니,
**맨 처음 삽입한 값이 가장 큰 경우** 자식노드들이 모두 출력될 때까지 출력이 씹힌다. 그 후 더 큰 값을 넣으면 출력이 되는걸로 보아, 값이 어딘가 **숨어있다**란 생각이 들었다.
숨을 곳은 한 곳이다. 배열의 `index`가 1부터 시작하니 `tree[0]`에 들어간 것이다. 그럼 push에서 tree를 교정할 때 문제가 됐을 것 같아 push를 확인했다.
``` cpp{5}
void maxHeap::push(int val) {
    this->size++;
    int cur = this->size;
    this->tree[this->size] = val;
    while(cur > 0) {
        if(tree[cur] > tree[cur/2])
            this->swap(cur, cur/2);
        else
            break;
        cur /= 2;
    }
}
```
이렇게 반복문 종료조건을 걸어두면, 맨 처음 값을 삽입할 때 `tree[1] == val`, `tree[0] == ?(initial value)`과 자리를 바꾸게 될 가능성이 있다.
아마 최소힙에서 이런 문제가 발생하지 않은 이유는 BOJ에서 malloc으로 할당한 배열의 값들을 0(혹은 그보다 작게) 초기화시켜서인 듯 하다.
해당 부분을 `while(cur > 1) {...}`로 수정하니 `맞았습니다!`를 받았다.
## 교훈
`index`를 다룰 땐 항상 조심, 또 조심해야 한다. 특히 *편의를 위해 1부터 시작시키자!* 라고 마음먹면면 **그럼 0을 잘 배재하자!!** 란 생각을 따라서 해야 한다.
## 최종 코드
[github](https://github.com/shinjawkwang/bojPractice/blob/master/datastructure/heap/11279.cpp)