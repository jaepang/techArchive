---
date: 2020-03-16
---
# 11726. 2×n 타일링
## 문제

2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.

아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.

![https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11726/1.png](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11726/1.png)

### 입력

첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)

### 출력

첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.

### 난이도

`Silver 3`

## Overview

`n`에 따른 타일의 가짓수를 `a[n]`이라 하면, 이는 다음과 같다.

- `a[2] = 2`
- `a[3] = 3`
- `a[4] = 5`
- `a[5] = 8`
- `a[6] = 13` ...

따라서, `n=4` 부터는 `a[n] = a[n-1]+a[n-2]`가 성립한다. 이를 바탕으로 `DP`로 문제를 풀어보자.

### 추가

이와 같은 규칙이 **왜 생기는가?**에 대한 성찰이 부족했다. 다음 문제를 풀어내려면 이를 정확히 알아야 하기에, 규칙을 정리해보자.

점화식 `a[n] = a[n-1]+a[n-2]`을 만드려면 최초 `a[1]`, `a[2]`는 우리가 직접 구해야 한다. `a[1]`은 한 칸이니까 당연히 1, `a[2]`는 세로로 두는 방법 한 가지, 가로로 두는 방법 한 가지로 총 두 가지다.

이제 `a[3]`을 보자. 즉, □□에서 □□□가 된 것이다. 이 경우, 새롭게 두 가지 방법이 가능하다. 새로 생긴 칸에 세로 블록 하나를 놓거나, 세로 생긴 칸 + 왼쪽 한 칸에 가로 블록 두개를 놓는 방법이다. 세로 블록을 놨다면 남은 건 2칸, 즉 `n-1`칸이다. 이 경우 가짓수는 `a[n-1]`가지 일 것이다. 가로블록을 놨다면 남은 건 1칸, 즉 `n-2`칸이다. 이 경우 가짓수는 `a[n-2]`가지이다. 이 외의 방법은 없으므로 총 가짓수는 `a[n-1]+a[n-2]`이다. 이러한 규칙으로 위 점화식이 생긴 것이다.

## first solution
```cpp
#include <stdio.h>

int a[1001] = {0, 1, 2, 3, };

int main() {
    int n;
    scanf("%d", &n);
    for(int i=4; i<=n; i++)
        a[i] = a[i-1]+a[i-2];
    printf("%d\n", a[n]%10007);
    return 0;
}
```

### 결과

`틀렸습니다`

### 문제가 뭘까?

배열을 출력해보자.
```sh
gitpod /workspace/bojPractice/dynamic_programming $ ./a
100
1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 -1323752223 ...
```
`n=100`도 채 되기 전에 `overflow`가 발생하게 된다. 값이 부정확하게 나오는 건 당연하다. 이를 막기 위해선 `10,007`로 나눈 나머지를 저장하는 과정을 계산 중간에 해야 할 것 같다. 즉, 값 자체를 저장하는 게 아닌, **나머지들을 저장하는 거다**. 이렇게 해도 값이 달라지지 않는다. 어차피 답도 나머지를 출력하는 거니, 출력에서 나누지 않고 출력해주면 된다. 혹은 큰 자료형으로 하는 건데, `long long`으로 해보니 여기서도 `overflow`가 발생한다.

:::tip
`n=1000`일 때 나머지를 취하지 않은 답은 `70330367711422815821835254877183549770181269836358732742604905087154537118196933579742249494562611733487750449241765991088186363265450223647106012053374121273867339111198139373125598767690091902245245323403501`라고 한다(...)
:::

## second solution
```cpp{9,11}
#include <stdio.h>

int a[1001] = {0, 1, 2, 3, };

int main() {
    int n;
    scanf("%d", &n);
    for(int i=4; i<=n; i++)
        a[i] = (a[i-1]+a[i-2]) % 10007;

    printf("%d\n", a[n]);
    return 0;
}
```

### 결과

`맞았습니다!!`

## 교훈

**범위를 벗어나는 수**는 매번 까먹고 실수하는 주제인 것 같다. 또 보통 자료형 변경 정도로 문제를 해결할 수 있었는데, 나머지로 해결하는 조금은 신박한 문제였다. 도움이 된 것 같다.

## 최종 코드

[github](https://github.com/shinjawkwang/bojPractice/blob/master/dynamic_programming/11726.cpp)