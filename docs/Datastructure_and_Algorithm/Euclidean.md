# 유클리드 호제법
> 유클리드 호제법(-互除法, Euclidean algorithm) 또는 유클리드 알고리즘은 2개의 자연수 또는 정식의 최대공약수를 구하는 알고리즘의 하나이다. 호제법이란 말은 두 수가 서로(互) 상대방 수를 나누어(除)서 결국 원하는 수를 얻는 알고리즘을 나타낸다. 2개의 자연수 `a`, `b`에 대해서 `a`를 `b`로 나눈 나머지를 `r`이라 하면**(단, `a>b`)**, `a`와 `b`의 최대공약수는 `b`와 `r`의 최대공약수와 같다. 이 성질에 따라, `b`를 `r`로 나눈 나머지 `r'`를 구하고, 다시 `r`을 `r'`로 나눈 나머지를 구하는 과정을 반복하여 **나머지가 0이 되었을 때 나누는 수**가 `a`와 `b`의 최대공약수이다.

[유클리드 호제법](https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C_%ED%98%B8%EC%A0%9C%EB%B2%95)

## 최대공약수

앞 설명을 식으로 일반화하면,`gcd(a,b) == gcd(b, a%b) == gcd(a%b, b%(a%b)) ...`이다. 즉, 코드로 구현할 때는 반복문으로 간편하게 구현할 수 있다.
```cpp
int gcd(int a, int b) {
        int tmp // swap을 위해
        while(b > 0) {
                tmp = b;
                b = a%b;
                a = tmp;
        }
        // "a%b가 0일 때 나누는 수"는, 식에 써있듯 b이지만, b=a%b로 값이 변동되고, 기존 b값은 a에 저장되므로 a를 반환한다.
        return a;
}
```

이렇게 최대공약수를 간단한 반복문으로 구할 수 있다. 그런데 이 코드는 a<b여도 작동한다. 이유가 뭘까? `a<b`라면, `a%b = a`이다. 즉, 다음과 같이 코드가 동작한다.
```
tmp = b;
b = a;
a = tmp;
```

 `swap(a,b)`와 같은 코드이다. 즉, a,b가 뒤바뀌어서 다음 반복문이 돌아간다. 그러면, `a>b` 조건을 성립하게 된다.

## 최소공배수

최소공배수는 최대공약수와 최소공배수의 관계를 이용해 구한다.

`a * b = gcd(a,b) * lcm(a,b)`

라는 성질이 있다. 따라서 최소공배수는 간단하게 구현할 수 있다.
```cpp
int lcm(int a,b) {
        return a*b / gcd(a,b);
}
```